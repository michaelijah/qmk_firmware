#include QMK_KEYBOARD_H


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */


enum Layer_name {
    HOME,
    SYMB,
    NUMP,
    FKEY,
    LEDC
};

typedef enum {
    TD_NONE,
    TD_UNKNOWN,
    TD_SINGLE_TAP,
    TD_SINGLE_HOLD,
    TD_DOUBLE_TAP,
    TD_DOUBLE_HOLD,
    TD_DOUBLE_SINGLE_TAP,
    TD_TRIPLE_TAP,
    TD_TRIPLE_HOLD
} td_state_t;

typedef struct {
    bool is_press_action;
    td_state_t state;
} td_tap_t;


// Tap dance declarations
enum {
    TD_ESC_CW, //tap for escape, double tap for caps word
    TD_L_PRN, //L paren and angle bracket
    TD_R_PRN, //Right paren and angle bracket
    TD_L_SQBR, //Left square bracket and curly bracey
    TD_R_SQBR, //Right square bracket and curly brace
};

td_state_t cur_dance(tap_dance_state_t *state);
void escape_capsword_finished(tap_dance_state_t *state, void *user_data);
void escape_capsword_reset(tap_dance_state_t *state, void *user_data);
void left_paren_angled_finished(tap_dance_state_t *state, void *user_data);
void left_paren_angled_reset(tap_dance_state_t *state, void *user_data);
void right_paren_angled_finished(tap_dance_state_t *state, void *user_data);
void right_paren_angled_reset(tap_dance_state_t *state, void *user_data);
void left_sqbrace_brace_finished(tap_dance_state_t *state, void *user_data);
void left_sqbrace_brace_reset(tap_dance_state_t *state, void *user_data);
void right_sqbrace_brace_finished(tap_dance_state_t *state, void *user_data);
void right_sqbrace_brace_reset(tap_dance_state_t *state, void *user_data);

//Tap Dance definitions
tap_dance_action_t tap_dance_actions[] = {
    //Tap once for Escape, twice for Caps Lock
    [TD_ESC_CW] = ACTION_TAP_DANCE_FN_ADVANCED(NULL,escape_capsword_finished,escape_capsword_reset),
    [TD_L_PRN] = ACTION_TAP_DANCE_FN_ADVANCED(NULL,left_paren_angled_finished,left_paren_angled_reset),
    [TD_R_PRN] = ACTION_TAP_DANCE_FN_ADVANCED(NULL,right_paren_angled_finished,right_paren_angled_reset),
    [TD_L_SQBR] = ACTION_TAP_DANCE_FN_ADVANCED(NULL,left_sqbrace_brace_finished,left_sqbrace_brace_reset),
    [TD_R_SQBR] = ACTION_TAP_DANCE_FN_ADVANCED(NULL,right_sqbrace_brace_finished,right_sqbrace_brace_reset),
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[0] = LAYOUT_ergodox_pretty(
KC_GRV,         KC_1,          KC_2,          KC_3,          KC_4,        KC_5,          OSM(MOD_MEH),  /**/  OSM(MOD_HYPR),  KC_6,           KC_7,        KC_8,          KC_9,          KC_0,             KC_MINS,
KC_TAB,         KC_Q,          KC_W,          KC_E,          KC_R,        KC_T,          TD(TD_L_SQBR),     /**/  TD(TD_R_SQBR),      KC_Y,           KC_U,        KC_I,          KC_O,          KC_P,             KC_BSLS,
TD(TD_ESC_CW),  LCTL_T(KC_A),  LALT_T(KC_S),  LSFT_T(KC_D),  LT(2,KC_F),  LGUI_T(KC_G),  /**/           /**/  /**/            RGUI_T(KC_H),   LT(1,KC_J),  RSFT_T(KC_K),  RALT_T(KC_L),  RCTL_T(KC_SCLN),  KC_QUOT,
KC_LSFT,        KC_Z,          KC_X,          KC_C,          KC_V,        KC_B,          TD(TD_L_PRN),      /**/  TD(TD_R_PRN),       KC_N,           KC_M,        KC_COMM,       KC_DOT,        KC_SLSH,          KC_RSFT,
MO(3),          MO(4),         KC_NO,         KC_F4,         KC_F5,       /**/           /**/           /**/  /**/            /**/            KC_LEFT,     KC_DOWN,       KC_UP,         KC_RGHT,          MO(3),
/**/            /**/           /**/           /**/           /**/         KC_DEL,        KC_PSCR,       /**/  KC_APP,         LSA(KC_ENTER),
/**/            /**/           /**/           /**/           /**/         /**/           KC_HOME,       /**/  KC_PGUP,
/**/            /**/           /**/           /**/           KC_SPC,      KC_BSPC,       KC_END,        /**/  KC_PGDN,        KC_ENT,         KC_SPC
),
	[1] = LAYOUT_ergodox_pretty(
KC_NO,  KC_EXLM,  KC_AT,    KC_HASH,  KC_DLR,   KC_PERC,  KC_NO,  /**/  KC_NO,  KC_NO,    KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,
KC_NO,  KC_PLUS,  KC_PIPE,  KC_LCBR,  KC_RCBR,  KC_AT,    KC_NO,  /**/  KC_NO,  KC_NO,    KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,
KC_NO,  KC_PMNS,  KC_UNDS,  KC_LPRN,  KC_RPRN,  KC_PEQL,  /**/    /**/  /**/    KC_RGUI,  KC_NO,  KC_RSFT,  KC_RALT,  KC_RCTL,  KC_NO,
KC_NO,  KC_PAST,  KC_BSLS,  KC_LBRC,  KC_RBRC,  KC_AMPR,  KC_NO,  /**/  KC_NO,  KC_NO,    KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,
KC_NO,  KC_CIRC,  KC_PERC,  KC_TILD,  KC_GRV,   /**/      /**/    /**/  /**/    /**/      KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,
/**/    /**/      /**/      /**/      /**/      KC_NO,    KC_NO,  /**/  KC_NO,  KC_NO,
/**/    /**/      /**/      /**/      /**/      /**/      KC_NO,  /**/  KC_NO,
/**/    /**/      /**/      /**/      KC_NO,    KC_NO,    KC_NO,  /**/  KC_NO,  KC_NO,    KC_NO
),
	[2] = LAYOUT_ergodox_pretty(
KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,  KC_NO,    KC_NO,  /**/  KC_NO,  KC_NO,  KC_NUM,  KC_PSLS,  KC_PAST,  KC_PMNS,  KC_NO,
KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,  KC_NO,    KC_NO,  /**/  KC_NO,  KC_NO,  KC_P7,   KC_P8,    KC_P9,    KC_PPLS,  KC_NO,
KC_NO,  KC_LCTL,  KC_LALT,  KC_LSFT,  KC_NO,  KC_LGUI,  /**/    /**/  /**/    KC_NO,  KC_P4,   KC_P5,    KC_P6,    KC_PPLS,  KC_NO,
KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,  KC_NO,    KC_NO,  /**/  KC_NO,  KC_NO,  KC_P1,   KC_P2,    KC_P3,    KC_PENT,  KC_NO,
KC_NO,  KC_NO,    KC_NO,    KC_NO,    KC_NO,  /**/      /**/    /**/  /**/    /**/    KC_P0,   KC_P0,    KC_PDOT,  KC_PENT,  KC_NO,
/**/    /**/      /**/      /**/      /**/    KC_NO,    KC_NO,  /**/  KC_NO,  KC_NO,
/**/    /**/      /**/      /**/      /**/    /**/      KC_NO,  /**/  KC_NO,
/**/    /**/      /**/      /**/      KC_NO,  KC_NO,    KC_NO,  /**/  KC_NO,  KC_NO,  KC_NO
),
	[3] = LAYOUT_ergodox_pretty(
KC_NO,    KC_F1,   KC_F2,   KC_F3,   KC_F4,   KC_F5,   KC_NO,  /**/  KC_NO,  KC_F6,    KC_F7,   KC_F8,    KC_F9,    KC_F10,   KC_NO,
KC_NO,    KC_F11,  KC_F12,  KC_F13,  KC_F14,  KC_F15,  KC_NO,  /**/  KC_NO,  KC_F16,   KC_F17,  KC_F18,   KC_F19,   KC_F20,   KC_NO,
KC_NO,    KC_F21,  KC_F22,  KC_F23,  KC_F24,  KC_NO,   /**/    /**/  /**/    KC_RGUI,  KC_NO,   KC_RSFT,  KC_RALT,  KC_RCTL,  KC_NO,
KC_NO,    KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,   KC_NO,  /**/  KC_NO,  KC_NO,    KC_NO,   KC_NO,    KC_NO,    KC_NO,    KC_NO,
KC_TRNS,  KC_NO,   KC_NO,   KC_NO,   KC_NO,   /**/     /**/    /**/  /**/    /**/      KC_NO,   KC_NO,    KC_NO,    KC_NO,    KC_TRNS,
/**/      /**/     /**/     /**/     /**/     KC_NO,   KC_NO,  /**/  KC_NO,  KC_NO,
/**/      /**/     /**/     /**/     /**/     /**/     KC_NO,  /**/  KC_NO,
/**/      /**/     /**/     /**/     KC_NO,   KC_NO,   KC_NO,  /**/  KC_NO,  KC_NO,    KC_NO
),
	[4] = LAYOUT_ergodox_pretty(
BL_TOGG,  BL_STEP,  BL_BRTG,  BL_ON,  BL_OFF,   BL_UP,     BL_DOWN,  /**/  BL_TOGG,  BL_STEP,  BL_BRTG,  BL_ON,  BL_OFF,  BL_UP,  BL_DOWN,
KC_NO,    KC_NO,    KC_NO,    KC_NO,  KC_NO,    KC_NO,     RGB_SPI,  /**/  RGB_VAI,  KC_NO,    KC_NO,    KC_NO,  KC_NO,   KC_NO,  KC_NO,
KC_NO,    KC_NO,    KC_NO,    KC_NO,  KC_NO,    KC_NO,     /**/      /**/  /**/      KC_NO,    KC_NO,    KC_NO,  KC_NO,   KC_NO,  KC_NO,
KC_NO,    KC_NO,    KC_NO,    KC_NO,  KC_NO,    KC_NO,     RGB_SPD,  /**/  RGB_VAD,  KC_NO,    KC_NO,    KC_NO,  KC_NO,   KC_NO,  KC_NO,
KC_NO,    KC_TRNS,  KC_NO,    KC_NO,  KC_NO,    /**/       /**/      /**/  /**/      /**/      KC_NO,    KC_NO,  KC_NO,   KC_NO,  KC_NO,
/**/      /**/      /**/      /**/    /**/      RGB_RMOD,  RGB_MOD,  /**/  RGB_M_K,  RGB_M_G,
/**/      /**/      /**/      /**/    /**/      /**/       RGB_HUI,  /**/  RGB_SAI,
/**/      /**/      /**/      /**/    RGB_TOG,  KC_NO,     RGB_HUD,  /**/  RGB_SAD,  RGB_M_B,  RGB_M_P
)
};

#if defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {

};
#endif // defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)




/* Return an integer that corresponds to what kind of tap dance should be executed.
 *
 * How to figure out tap dance state: interrupted and pressed.
 *
 * Interrupted: If the state of a dance is "interrupted", that meeans that another key has been hit 
 * under the tapping term. This is typically indictive that you are tryhinmg to "tap" the key. 
 *
 * Pressed: Whether or not the key is still being pressed. If this value is true, that means the tapping term
 * has ended, but the key is still being pessed down. This generally means the key is being "held".
 *
 * One thing that is currenlty not possible with qmk software in regards to tap dance is to mimic the "permissive hold"
 * feature. In general, advanced tap dances do not work well if they are used with commonly typed letters.
 * For example "A". Tap dances are best used on non-letter keys that are not hit while typing letters.
 *
 * Good places to put an advanced tap dance:
 * z q x j k v b , any function key, home/end, comma, semi-colon
 *
 * Criteria for "good placement" of a tap dance key:
 * Not a key that is hit frequently in a sentence
 * Not a key that is used frequently to double tap, for example 'tab' is often double tapped in a terminal, or
 * in a web form. So 'tab' would be a poor choic for a tap dance. 
 * Letters used in common words as a double. For example 'p' in 'pepper'. If a tap dance function existed on the
 * letter 'p', the word 'pepper' would be quite frustating to type.
 *
 * For the third point, there does exist the 'TD_DOUBLE_SINGLE_TAP' but it is not well tested.
 */
td_state_t cur_dance(tap_dance_state_t *state){
    if(state->count == 1){
        if(state->interrupted || !state->pressed) return TD_SINGLE_TAP;
        //Key has not been interrupted, but the key is still held. Means you want to send a 'HOLD'.
        else return TD_SINGLE_HOLD;
    } else if (state->count == 2){
        //TD_DOUBLE_SINGLE_TAP is to distinguis between typing "pepper", and actually wanting a double tap
        //action when hitting 'pp'. Suggested use case for this return value is when you want to send two 
        //keystrokes of the key, and not the 'double tap' action/macro
        if (state->interrupted) return TD_DOUBLE_SINGLE_TAP; 
        else if(state->pressed) return TD_DOUBLE_HOLD;
        else return TD_DOUBLE_TAP;
    }

    //Assumes no one is trying to type the same letter three times (at lease not quickly).
    //If your tap dance key is 'KC_W', and you want to type "www" quickly then you'll need to add 
    //an exception here to return a 'TD_TRIPLE_SINGLE_TAP', and define that enum just like we did for
    //the 'TD_DOUBLE_SINGLE_TAP'
    if(state->count == 3){
        if(state->interrupted || !state->pressed) return TD_TRIPLE_TAP;
        else return TD_TRIPLE_HOLD;

    }else return TD_UNKNOWN;
}

//Create an instance of 'td_tap_t' for the 'x' tap dance
static td_tap_t esctap_state = {
    .is_press_action = true,
    .state = TD_NONE
};


 
void escape_capsword_finished(tap_dance_state_t *state, void *user_data)
{
    esctap_state.state = cur_dance(state);

    switch(esctap_state.state){
        case TD_SINGLE_TAP: register_code(KC_ESC); break;
        case TD_DOUBLE_TAP: caps_word_toggle(); break;
        default: break;                            
    }
};

void escape_capsword_reset(tap_dance_state_t *state, void *user_data)
{
    switch(esctap_state.state){
        case TD_SINGLE_TAP: unregister_code(KC_ESC); break;
        case TD_DOUBLE_TAP: break;
        default: break;                            
    }
};

//Create an instance of 'td_tap_t' for the 'x' tap dance
static td_tap_t lparentap_state = {
    .is_press_action = true,
    .state = TD_NONE
};


 
void left_paren_angled_finished(tap_dance_state_t *state, void *user_data)
{
    lparentap_state.state = cur_dance(state);

    switch(lparentap_state.state){
        case TD_SINGLE_TAP: register_code(KC_LSFT); register_code(KC_9); break;
        case TD_DOUBLE_TAP: register_code(KC_LSFT); register_code(KC_COMM); break;
        default: break;                            
    }
};

void left_paren_angled_reset(tap_dance_state_t *state, void *user_data)
{
    switch(lparentap_state.state){
        case TD_SINGLE_TAP: unregister_code(KC_9); unregister_code(KC_LSFT); break;
        case TD_DOUBLE_TAP: unregister_code(KC_COMM); unregister_code(KC_LSFT); break;
        default: break;                            
    }
};

//Create an instance of 'td_tap_t' for the 'x' tap dance
static td_tap_t rparentap_state = {
    .is_press_action = true,
    .state = TD_NONE
};


 
void right_paren_angled_finished(tap_dance_state_t *state, void *user_data)
{
    rparentap_state.state = cur_dance(state);

    switch(rparentap_state.state){
        case TD_SINGLE_TAP: register_code(KC_LSFT); register_code(KC_0); break;
        case TD_DOUBLE_TAP: register_code(KC_LSFT); register_code(KC_DOT); break;
        default: break;                            
    }
};

void right_paren_angled_reset(tap_dance_state_t *state, void *user_data)
{
    switch(rparentap_state.state){
        case TD_SINGLE_TAP: unregister_code(KC_0); unregister_code(KC_LSFT); break;
        case TD_DOUBLE_TAP: unregister_code(KC_DOT); unregister_code(KC_LSFT); break;
        default: break;                            
    }
};

//Create an instance of 'td_tap_t' for the 'x' tap dance
static td_tap_t lsqbracetap_state = {
    .is_press_action = true,
    .state = TD_NONE
};


 
void left_sqbrace_brace_finished(tap_dance_state_t *state, void *user_data)
{
    lsqbracetap_state.state = cur_dance(state);

    switch(lsqbracetap_state.state){
        case TD_SINGLE_TAP: register_code(KC_LBRC); break;
        case TD_DOUBLE_TAP: register_code(KC_LSFT); register_code(KC_LBRC); break;
        default: break;                            
    }
};

void left_sqbrace_brace_reset(tap_dance_state_t *state, void *user_data)
{
    switch(lsqbracetap_state.state){
        case TD_SINGLE_TAP: unregister_code(KC_LBRC); break;
        case TD_DOUBLE_TAP: unregister_code(KC_LBRC); unregister_code(KC_LSFT); break;
        default: break;                            
    }
};

//Create an instance of 'td_tap_t' for the 'x' tap dance
static td_tap_t rsqbracetap_state = {
    .is_press_action = true,
    .state = TD_NONE
};


 
void right_sqbrace_brace_finished(tap_dance_state_t *state, void *user_data)
{
    rsqbracetap_state.state = cur_dance(state);

    switch(rsqbracetap_state.state){
        case TD_SINGLE_TAP: register_code(KC_RBRC); break;
        case TD_DOUBLE_TAP: register_code(KC_LSFT); register_code(KC_RBRC); break;
        case TD_SINGLE_HOLD: tap_code(KC_EQL); break;
        case TD_DOUBLE_HOLD: tap_code(KC_EQL); tap_code(KC_EQL); break;
        default: break;                            
    }
};

void right_sqbrace_brace_reset(tap_dance_state_t *state, void *user_data)
{
    switch(rsqbracetap_state.state){
        case TD_SINGLE_TAP: unregister_code(KC_RBRC); break;
        case TD_DOUBLE_TAP: unregister_code(KC_RBRC); unregister_code(KC_LSFT); break;
        case TD_SINGLE_HOLD: break;
        case TD_DOUBLE_HOLD: break;
        default: break;                            
    }
};
